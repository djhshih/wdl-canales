task bam_to_fastq_paired_fast {
	File input_bam
	String sample_id

	Int cpu
	Int memory_gb
	Int preemptible_tries

	Int memory_mb_thread = floor(0.5 * memory_gb * 1024 / cpu)
	Int diskspace_gb = ceil(10 * size(input_bam, "GB"))

	command <<<
		set -eu

		# sort the BAM file by qname (read name)
		# s.t. downstream insert size calculation is not biased
		samtools sort -@ ${cpu} -m ${memory_mb_thread}M -n -l l -o qname-sorted.bam ${input_bam}
		rm ${input_bam}

		# extract reads from the BAM file and write to fifo
		# NB will *not* work if the BAM file have unpaired reads that are not marked!
		mkfifo r1.fastq
		mkfifo r2.fastq
		samtools fastq qname-sorted.bam \
			-0 ${sample_id}_unpaired.fastq \
			-1 r1.fastq \
			-2 r2.fastq \
			&

		# consume reads from fifos and create interleaved fastq
		pairfq r1.fastq r2.fastq /dev/stdout ${sample_id}_unpaired_unmarked.fastq \
			| gzip > ${sample_id}_R1_R2.fastq.gz
		rm r1.fastq r2.fastq

		gzip ${sample_id}_unpaired.fastq
		gzip ${sample_id}_unpaired_unmarked.fastq
	>>>

	output {
		File fastq_r1_r2 = "${sample_id}_R1_R2.fastq.gz"
		File fastq_unpaired = "${sample_id}_unpaired.fastq.gz"
		File fastq_unpaired_unmarked = "${sample_id}_unpaired_unmarked.fastq.gz"
	}

	runtime {
		docker: "djhshih/seqkit:0.1"
		memory: "${memory_gb} GB"
		cpu: "${cpu}"
		disks: "local-disk ${diskspace_gb} HDD"
		preemptible: preemptible_tries
	}
}
